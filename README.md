#如何统计一个接口在短时间内的失败率？
> **必须使用apcu扩展**
统计失败率这个还是挺有用的，比如说我想在失败率达到什么情况下执行熔断或其他操作；
##**我需要一个概率来尽可能精准的知道这个事儿；**

肯定不能是一个积累量，比如写死在内存里几个键不断地自增，成功的成功键位对应+1，失败的失败对硬键位+1；
这样做是可以但缺点也很明显，当我前面不断的成功的时候，突然接口开始报错了，你想，前面成功的数量都已经积累了很多了，错误必须达到同等的量的时候才能触发，灵敏度不够；
那样得定时抛弃一些积累量，并且如果我们只是统计小时间段内的成功量和失败量，只要时间缩短的足够小，还是可以进行有效的统计的，下面开始建模；

### 1. 接口成功和接口失败各自建立10个盒子
成功的盒子命名为
 - suc0
 - suc1
 - suc2
 - ...
 - suc9
失败的盒子命名为
 - fail0
 - fail1
 - fail2
 - ...
 - fail9
盒子中装有从0开始的计数器；
### 2. 计算当前盒子编号
当前就是指的当前的时间戳；

```
num = floor(timestamp/10)%10;
```
对就这么简单，当前时间戳除以10并向下取整，再对其取余数，相当于每10秒会对应一个盒子编号，编号从0-9；

### 3. 开始统计
拿到当前时间戳得到当前的盒子数，如果接口返回的是成功的，suc当前盒编号的盒子里计数器+1。如果接口是失败的fail当前盒子编号的盒子数中的计数器+1；

### 4. 状态转移时，清空无关盒子里计数器中的值
统计的时候，突然时间戳算出来的盒子就到了下一个盒子了，其实发现是下一个盒子还是很容易的，盒子里的计数器里的数都是0，要做这么几个操作，假设当前的盒子编号为i

对于成功盒子，除了`i`,`i-1`,`i-2`编号以外的盒子，其余成功盒子中计数器全部清空置0，至于为什么还有`i-1`,`i-2`这个下面说；
对于失败盒子，除了i编号以外的盒子，其余失败盒子中计数器全部清空置0；

### 5. 获得成功和失败的统计量
其实就是获得当前成功盒子编号中的数量，但是我们保留了编号为i,i-1,i-2编号的盒子，我打算*求和取个平均值*作为成功的统计量，这样做是为了防止数据抖动过大而采取的措施，有可能访问数据会在上个10s暴增下个10秒为0这样的抖动很可能有，所以我保留了三个盒子来保证数据的平滑性，也就是上面所说的`i`,`i-1`,`i-2`盒子；而失败的盒子只取了当前的盒子，为了保留失败的灵敏度，其实失败的也能平滑进行统计，但是可能会丧失一定的灵敏度；

另外，由于我们是打算统计失败的概率，有一种可能，在最开始进入统计系统时候，所有盒子都是0，上来失败了1次导致失败率是100%，灵敏度过大，所以如果系统在统计时，应该设定一个最小的成功阈值，成功数在最开始不到这个阈值的时候，应该返回一个恒定值而不是真的统计值，本案例中的阈值和恒定值都是50，也就是说不到50的统计量，成功盒子中计数器的值就是50（注意：成功数量是3个盒子的和取平均）；

### 6. 计算当前失败的概率，启动一个定时锁；

```
失败概率 = 当前失败数/（失败数+成功数的均值）；
```
一旦失败概率大于我们设定的值的时候，我们开启一个定时锁，并清空所有的盒子定时器置0，在有锁状态下，所有统计都不工作，直到锁状态消失自动进入下一轮的统计；

enjoy it.
